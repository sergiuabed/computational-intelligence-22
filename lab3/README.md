# Lab 3: Policy Search

## Info for the Reader

Group members:

- Sergiu Abed (s295149)

- Luca Balduzzi (s303326)

- Riccardo Musumarra (s295103)

Main files on which the code has been developed:

- nim_utils.py
- evolution.py
- main.py

## Task

See problem description [here](https://github.com/squillero/computational-intelligence/blob/master/2022-23/lab3_nim.ipynb).

## Task 3.1: An agent using fixed rules based on nim-sum (i.e., an expert system)

Provided by professor in the link above. (see "pure-random" and "optimal_strategy")

## Task 3.2: An agent using evolved rules

### Approach

The solution is based on a genetic algorithm using strategy 2 (as called by the professor in the slides), in which the offspring are put together with the population (note that the offspring are not introduced in the population until all the offspring have been generated) and then the best individuals among the current population plus the offspring are chosen for the next generation. In short, we are using ($\mu$ + $\lambda$) strategy.

An offspring is generated by one of the two genetic operators: mutation and recombination.

In this solution, 4 hard-coded rules are used for building the agents. An agent differs from another by the probabolity with which it will use a certain hard-coded rule.

The following are the hard-coded rules:

- pure-random: choose any possible move randomly and perform it (provided by the professor)

- greedy_pick: this rule assumes that every time the opponent makes a move, it will always take all the elements in a row, leaving it empty. In such a (very unlikely) situation, the player will also pick all the elements in a row ONLY IF there are n odd nr of active rows left. Otherwise, it will leave only one element in the row, hoping that the opponent will empty that row (or any other) so that the nr of rows is odd.

- even_odd: pick a random row and remove from it an odd random nr of elements from it if the index of the row is odd. Otherwise, remove an even random nr of elements

- shy_pick: always pick only one object from a random row

### Terminology

    - gene = probability of a rule to be used for performing a ply
    - genome = tuple of genes. It's described by the named tuple "Genome"
    - individual = in this case, it's the same thing as a genome
    - fittness = percentage of matches won against an opponent using just fixed rules (e.g. pure_random or optimal_strategy)
    - locus = index within a genome

### Parent selection

Based on tournament approach. Here, we used tournaments of size 20. As explained in class, the higher tournament size, the higher selective pressure.

### Genetic operators

#### Mutation

Randomly select a locus within the genome of the individual to be mutated and an allele (i.e. new probability) to replace the gene on that locus.

#### Recombination

It takes as input two parents, splits their genomes and combines them to form a new individual.

### Fitness

We considered the fitness to be the percentage of matches (out of NUM_MATCHES) won against an opponent using just fixed rules (e.g. pure_random or optimal_strategy).

note: in order to obtain consistent fitness results, the hyperparameter NUM_MATCHES must be large (here it was set to 100). Otherwise, computing the fitness on the same individual multiple times will give very different results. Also, due to the large NUM_MATCHES value, the execution of the code is quite slow (~ 7min)

### Survival selection

The fittest $\mu$ individuals are selected for the population of the next generation.

### Generation

Offspring are generated either through mutation or recombination. The choice is done randomly. The parents are chosen through tournaments.
Once the parents and the genetic operator are chosen, the operator is applied on the parent(s).
Once the offspring generation is over, they are put in the population and survival selection is performed.

### Results

Results obtained setting the hyperparameters:
NUM_MATCHES = 100
NIM_SIZE = 10
POPULATION_SIZE = 10
OFFSPRING = 5
GENERATIONS = 10

Opponent: pure_random

Running the code multiple times, the following solutions were found:

- Genome(pure_random_p=0.15174121646190042, greedy_p=0.6540699798440321, even_odd_p=0.02427360046175844, shy_pick=0.16991520323230905)
  - win rate: 0.83

- Genome(pure_random_p=0.08799303781985655, greedy_p=0.5976836230147908, even_odd_p=0.17676669405262752, shy_pick=0.13755664511272517)
  - win rate: 0.8

- Genome(pure_random_p=0.11361286340732811, greedy_p=0.6506918540601518, even_odd_p=0.18591195830290055, shy_pick=0.04978332422961946)
  - win rate: 0.81

## Task 3.3: An agent using minma

Just a classical implementation of the minmax decision rule. A game tree is generated enumerating each possible move in every ply, with a depth limited by a look ahead option. A heuristic function evaluates a node based on whether its nim-sum is zero or not, or whether it represents a positive or negative critical situation (where the nim-sum strategy fails to determine the best action). The minmax strategy wins against a random one competes against a nim-sum opponent, but only for a look-ahead of 1 ply. This is probably due to the horizon effect.

## Sources

- Giovanni Squillero's Github Computational Intelligence

- one-max.ipynb

- lab3_nim.ipynb

- Giovanni Squillero's Slides of the course Computational Intelligence 2022/2023
